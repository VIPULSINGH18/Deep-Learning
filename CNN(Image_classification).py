# -*- coding: utf-8 -*-
"""CNN(image_classification).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oDclduAinu0qcnB0skyYoCtBp-X6t5F6
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split

from sklearn.linear_model import Perceptron  #used to classify two or more than two classes in output layer if data is linear separable...
from sklearn.metrics import accuracy_score, classification_report,confusion_matrix

from tensorflow.keras.models import Sequential  #sequential lets us build a neural network layer-by-layer in keras..

from tensorflow.keras.layers import Dense  #it is used for building hidden layers in ANN...
from tensorflow.keras.layers import Conv2D    #Conv2d extracts features(edges,boundaries,shape)
from tensorflow.keras.layers import Flatten #flattens 2d/3d vector into 1d vector
from tensorflow.keras.layers import MaxPooling2D  #this reduce the size of feature maps which is created through different filters...
from tensorflow.keras.layers import Dropout   #remove unnecesary features to prevent overfitting

from tensorflow.keras.utils import to_categorical

from tensorflow import keras  #importing keras from tensorflow to independently use it

(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()  #importind dataset directly from keras...

x_train

x_test

y_train

y_test

#in our dataset values is from 0 to 255 now we will divide every data from 255 so that our each and every values comes into the range of 0 to 1...

x_train= x_train.astype("float32")/255.0
x_test= x_test.astype("float32")/255.0

#we will do one hot coding of output labels of training and testing data
y_train_cat= to_categorical(y_train,10)
y_test_cat= to_categorical(y_test,10)

#classifying our images using perceptron

perceptron= Sequential([
    Flatten(input_shape=(28,28)),
    Dense(10,activation="softmax")
])

perceptron.compile(optimizer="sgd",loss="categorical_crossentropy",metrics=["accuracy"])
history_percep= perceptron.fit(x_train,y_train_cat,epochs=10,batch_size=32,validation_data=(x_test,y_test_cat),verbose=1)

accuracy_percep= perceptron.evaluate(x_test,y_test_cat,verbose=0) #this evaluate function returns the pair of loss and best accuracy score
accuracy_percep  #final accuracy using perceptron

#now we will do image classification using ANN....
ann= Sequential([
    Flatten(input_shape=(28,28)),
    Dense(128,activation="relu"),
    Dense(64,activation="relu"),
    Dense(10,activation="softmax")
])

ann.compile(optimizer="adam",loss="categorical_crossentropy",metrics=["accuracy"])
history_ann= ann.fit(x_train,y_train_cat,epochs=5,batch_size=32,validation_data=(x_test,y_test_cat),verbose=1)

accuracy_ann= ann.evaluate(x_test,y_test_cat,verbose=0)
accuracy_ann  #final accuracy using ann

##now we will do image classification using CNN....

#we have three color channels:
# 1: grey scale (color intensity from 0 to 255), 2: color made of combination with 2 different colors, 3: RGB(color made with three colors)

x_train_cnn= x_train.reshape(-1,28,28,1)
x_test_cnn= x_test.reshape(-1,28,28,1)

cnn= Sequential([
    Conv2D(32,kernel_size=(3,3),activation="relu",input_shape=(28,28,1)),
    MaxPooling2D(pool_size=(2,2)),
    Conv2D(64,kernel_size=(3,3),activation="relu"),
    MaxPooling2D(pool_size=(2,2)),
    Flatten(),
    Dense(128,activation="relu"),
    Dropout(0.5),  #randomly deselect half of the hidden layer at every epoch steps , it is done to prevent overfitting...
    Dense(10,activation="softmax")

])

cnn.compile(optimizer="adam",loss="categorical_crossentropy",metrics=["accuracy"])
history_cnn= cnn.fit(x_train_cnn,y_train_cat,epochs=5,batch_size=32,validation_data=(x_test_cnn,y_test_cat),verbose=1)

cnn_accuracy= cnn.evaluate(x_test_cnn,y_test_cat,verbose=0)
cnn_accuracy  #final accuracy using cnn


def plot_training(history, title):
    plt.figure(figsize=(12,4))
    plt.subplot(1,2,1)
    plt.plot(history.history['accuracy'], label="Train")
    plt.plot(history.history['val_accuracy'], label="Val")
    plt.title(f"{title} Accuracy")
    plt.legend()

    plt.subplot(1,2,2)
    plt.plot(history.history['loss'], label="Train")
    plt.plot(history.history['val_loss'], label="Val")
    plt.title(f"{title} Loss")
    plt.legend()
    plt.show()


